C51 COMPILER V9.60.7.0   UART0                                                             11/20/2024 17:46:08 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART0
OBJECT MODULE PLACED IN .\Release\Objects\uart0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart0.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\L
                    -istings\uart0.lst) OBJECT(.\Release\Objects\uart0.obj)

line level    source

   1          #include "uart0.h"
   2          
   3          #include <string.h> // memset()
   4          
   5          // è®¾ç½®çš„æ³¢ç‰¹ç‡éœ€è¦é€‚é…å•ç‰‡æœºçš„æ—¶é’Ÿï¼Œè¿™é‡Œç›´æ¥ä½¿ç”¨äº†å®˜æ–¹çš„ä»£ç 
   6          #define USER_UART0_BAUD ((SYSCLK - UART0_BAUDRATE) / (UART0_BAUDRATE))
   7          
   8          // ç”¨æ¥å­˜æ”¾æ¥æ”¶çš„æ•°æ®å¸§çš„ç¼“å†²åŒº
   9          volatile u8 uart0_recv_buf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)][FRAME_MAX_LEN] = {0};
  10          // ç”¨äºè®°å½•æ¥æ”¶ç¼“å†²åŒºçš„å¯¹åº”çš„æ•°æ®å¸§çš„é•¿åº¦
  11          volatile u8 uart0_recv_len[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  12          // è®°å½•ç¼“å†²åŒºä¸­å¯¹åº”çš„ä½ç½®æ˜¯å¦æœ‰æ•°æ®çš„æ ‡å¿—ä½ï¼ˆæ•°ç»„ï¼‰
  13          // ä¾‹å¦‚ï¼Œç¼“å†²åŒºä¸‹æ ‡0çš„ä½ç½®æœ‰æŒ‡ä»¤ï¼Œæ ‡å¿—ä½æ•°ç»„ä¸‹æ ‡0çš„å…ƒç´ å€¼ä¸º1ï¼Œæ²¡æœ‰æŒ‡ä»¤ï¼Œå
             -…ƒç´ çš„å€¼ä¸º0
  14          volatile u8 recved_flagbuf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  15          
  16          volatile u8 flagbuf_valid_instruction[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0}; // å­˜æ”¾æœ‰åˆæ³•æŒ‡ä»¤
             -çš„æ ‡å¿—ä½æ•°ç»„
  17          
  18          // ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ï¼Œæ¥æ”¶ä¸€å¸§çš„æ ‡å¿—ä½ï¼Œ0--å‡†å¤‡æ¥æ”¶ä¸€å¸§çš„ç¬¬ä¸€ä¸ªå­—èŠ‚ï¼Œ1--æ
             -­£åœ¨æ¥æ”¶è¯¥å¸§çš„æ•°æ®
  19          static volatile bit flag_is_recving_data = 0;
  20          static volatile u8 frame_len = 0;    // è®°å½•ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ï¼Œå½“å‰è¦æ¥æ”¶çš„æ•°æ®å¸§çš„
             -å­—èŠ‚æ•°
  21          static volatile u8 cur_recv_len = 0; // è®°å½•ä¸²å£ä¸­æ–­æœåŠ¡å‡½æ•°ä¸­ï¼Œå½“å‰å·²æ¥æ”¶çš„æ•°æ®å¸§çš„
             -å­—èŠ‚æ•°
  22          volatile u8 recv_frame_cnt = 0;      // æ¥æ”¶åˆ°çš„æ•°æ®å¸§çš„ä¸ªæ•°
  23          
  24          static volatile u32 blank_index = 0; // è®°å½•å½“å‰å­˜æ”¾æ•°æ®å¸§çš„ç¼“å†²åŒºçš„ç©ºçš„åœ°æ–¹(ç¼“å†²åŒºä¸
             -‹æ ‡)ï¼Œå‡†å¤‡å­˜æ”¾ä¸€å¸§çš„æ•°æ®
  25          
  26          // bit test_bit = 0; // æµ‹è¯•ç”¨
  27          
  28          // u32 test_val = 0; // æµ‹è¯•ç”¨
  29          
  30          // é‡å†™putchar()å‡½æ•°
  31          char putchar(char c)
  32          {
  33   1          uart0_sendbyte(c);
  34   1          return c;
  35   1      }
  36          
  37          // uart0åˆå§‹åŒ–
  38          // æ³¢ç‰¹ç‡ç”±å® UART0_BAUDRATE æ¥å†³å®š
  39          void uart0_config(void)
  40          {
  41   1          // ç”µè·¯æ¿ä¸Šï¼ŒP11ä¸ºå‘é€å¼•è„šï¼ŒP12ä¸ºæ¥æ”¶å¼•è„š
  42   1          P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
  43   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // è¾“å‡ºæ¨¡å¼
  44   1          FOUT_S11 |= GPIO_FOUT_UART0_TX;   // é…ç½®P11ä¸ºUART0_TX
  45   1          FIN_S7 |= GPIO_FIN_SEL_P12;       // é…ç½®P12ä¸ºUART0_RX
  46   1      
  47   1          __EnableIRQ(UART0_IRQn); // æ‰“å¼€UARTæ¨¡å—ä¸­æ–­
C51 COMPILER V9.60.7.0   UART0                                                             11/20/2024 17:46:08 PAGE 2   

  48   1          IE_EA = 1;               // æ‰“å¼€æ€»ä¸­æ–­
  49   1      
  50   1          UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // é…ç½®æ³¢ç‰¹ç‡é«˜å…«ä½
  51   1          UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // é…ç½®æ³¢ç‰¹ç‡ä½å…«ä½
  52   1          UART0_CON0 = UART_STOP_BIT(0x0) |
  53   1                       UART_RX_IRQ_EN(0x1) |
  54   1                       UART_EN(0x1); // 8bitæ•°æ®ï¼Œ1bitåœæ­¢ä½ï¼Œä½¿èƒ½RXä¸­æ–­
  55   1      
  56   1          // memset(uart0_recv_buf, 0, sizeof(uart0_recv_buf));
  57   1      }
  58          
  59          // UART0ä¸­æ–­æœåŠ¡å‡½æ•°ï¼ˆæ¥æ”¶ä¸­æ–­ï¼‰
  60          void UART0_IRQHandler(void) interrupt UART0_IRQn
  61          {
  62   1          volatile u8 uart0_tmp_val = 0;
  63   1      
  64   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
  65   1          __IRQnIPnPush(UART0_IRQn);
  66   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
  67   1          // RXæ¥æ”¶å®Œæˆä¸­æ–­
  68   1          if (UART0_STA & UART_RX_DONE(0x1))
  69   1          {
  70   2              
  71   2          } // if (UART0_STA & UART_RX_DONE(0x1))
  72   1      
  73   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
  74   1          __IRQnIPnPop(UART0_IRQn);
  75   1      }
  76          
  77          // UART0å‘é€ä¸€ä¸ªå­—èŠ‚æ•°æ®çš„å‡½æ•°
  78          void uart0_sendbyte(u8 senddata)
  79          {
  80   1          while (!(UART0_STA & UART_TX_DONE(0x01)))
  81   1              ;
  82   1          UART0_DATA = senddata;
  83   1          while (!(UART0_STA & UART_TX_DONE(0x01))) // ç­‰å¾…è¿™æ¬¡å‘é€å®Œæˆ
  84   1              ;
  85   1      }
  86          
  87          // é€šè¿‡uart0å‘é€è‹¥å¹²æ•°æ®
  88          void uart0_send_buff(u8 *buf, u8 len)
  89          {
  90   1          u8 i = 0;
  91   1          for (; i < len; i++)
  92   1          {
  93   2              uart0_sendbyte(buf[i]);
  94   2          }
  95   1      }
  96          
  97          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    117    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     46       5
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
