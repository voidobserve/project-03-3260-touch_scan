C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/20/2024 15:06:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) 
                    -INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\
                    -Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          // å¤šå°‘ä¸ªè„‰å†²è¡¨ç¤ºä¸€åœˆ
   4          #ifndef PULSE_PER_TURN
   5          #define PULSE_PER_TURN (16)
   6          #endif // å¤šå°‘ä¸ªè„‰å†²è¡¨ç¤ºä¸€åœˆ
   7          
   8          // è½¦è½®ä¸€åœˆè¡¨ç¤ºå¤šå°‘æ¯«ç±³
   9          #ifndef MM_PER_TURN
  10          #define MM_PER_TURN (1795) // ä¸€åœˆ1795æ¯«ç±³
  11          #endif                   // è½¦è½®ä¸€åœˆè¡¨ç¤ºå¤šå°‘æ¯«ç±³
  12          
  13          static volatile u32 detect_speed_pulse_cnt = 0; // è„‰å†²è®¡æ•°å€¼
  14          volatile u32 distance = 0;         // å­˜æ”¾æ¯æ¬¡æ‰«ææ—¶èµ°è¿‡çš„è·¯ç¨‹ï¼ˆå•ä½ï¼šæ¯«ç±³ï¼‰-->ç”¨äºé‡
             -Œç¨‹è¡¨çš„è®¡æ•°
  15          
  16          // æ—¶é€Ÿæ‰«æçš„é…ç½®
  17          void speed_scan_config(void)
  18          {
  19   1          // ä½¿ç”¨IOä¸­æ–­æ¥å¯¹è„‰å†²è®¡æ•°
  20   1          __SetIRQnIP(P0_IRQn, P0_IQn_CFG); // è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§
  21   1          __EnableIRQ(P0_IRQn);             // ä½¿èƒ½P1ä¸­æ–­
  22   1          IE_EA = 1;                        // ä½¿èƒ½æ€»å¼€å…³
  23   1      
  24   1          P0_MD0 &= ~GPIO_P02_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  25   1          P0_PD |= GPIO_P02_PULL_PD(0x1);    // é…ç½®ä¸ºä¸‹æ‹‰
  26   1          P0_IMK |= GPIO_P02_IRQ_MASK(0x1);  // ä½¿èƒ½IOä¸­æ–­
  27   1          P0_TRG0 &= ~GPIO_P02_TRG_SEL(0x3);
  28   1          P0_TRG0 |= GPIO_P02_TRG_SEL(0x2); // é…ç½®ä¸Šå‡æ²¿è§¦å‘
  29   1      }
  30          
  31          // é€Ÿåº¦æ‰«æå‡½æ•°
  32          void speed_scan(void)
  33          {
  34   1          static u32 last_speed = 0;                  // è®°å½•ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„é€Ÿåº¦
  35   1      
  36   1          static u8 speed_increases_cnt = 0; // æ£€æµ‹é€Ÿåº¦æ˜¯å¦åœ¨å¢åŠ çš„è®¡æ•°å€¼
  37   1          static u8 speed_decreases_cnt = 0; // æ£€æµ‹é€Ÿåº¦æ˜¯å¦åœ¨å‡å°‘çš„è®¡æ•°å€¼
  38   1      
  39   1          u32 cur_speed = 0; // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
  40   1      
  41   1          if (tmr2_cnt >= 1000) // å¦‚æœç»è¿‡äº†100ms
  42   1          {
  43   2              tmr2_cnt = 0; // æ¸…é™¤å®šæ—¶å™¨è®¡æ•°
  44   2              // è®¡ç®—1000mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
  45   2              // è„‰å†²ä¸ªæ•° / ä¸€åœˆæœ‰å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆè¡¨ç¤ºèµ°è¿‡äº†å¤šå°‘mm == è¯¥æ®µæ—¶é—´å†…èµ°è¿
             -‡çš„è·ç¦»(å•ä½:mm)
  46   2              cur_speed = detect_speed_pulse_cnt * MM_PER_TURN / PULSE_PER_TURN;
  47   2              distance += cur_speed; // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³(å› ä¸ºæ²¡æœ‰ä½¿ç”¨æµ®ç‚¹ç±»å‹,é
             -œ€è¦ç´¯åŠ ,å¦åˆ™åç»­ç»Ÿè®¡é‡Œç¨‹æ—¶å°±ä¼šä¸¢å¤±æ•°æ®)
  48   2              // è®¡ç®—å¾—å‡º1å°æ—¶èƒ½èµ°è¿‡å¤šå°‘æ¯«ç±³
  49   2              // tmp = tmp * 4 * 3600;
  50   2              cur_speed *= 14400;
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/20/2024 15:06:13 PAGE 2   

  51   2              cur_speed /= 1000000; // æ¢ç®—æˆ km/hçš„å•ä½
  52   2              detect_speed_pulse_cnt = 0; // æ¸…é™¤è„‰å†²è®¡æ•°
  53   2      
  54   2              if (cur_speed > last_speed)
  55   2              {
  56   3                  speed_decreases_cnt = 0;
  57   3                  speed_increases_cnt++;
  58   3      
  59   3                  if (speed_increases_cnt >= 10)
  60   3                  {
  61   4                      last_speed = cur_speed;
  62   4      
  63   4                      fun_info.speed = cur_speed;
  64   4                      flag_get_speed = 1;
  65   4                  }
  66   3              }
  67   2              else if (cur_speed < last_speed)
  68   2              {
  69   3                  speed_increases_cnt = 0;
  70   3                  speed_decreases_cnt++;
  71   3                  if (speed_decreases_cnt >= 10)
  72   3                  {
  73   4                      last_speed = cur_speed;
  74   4      
  75   4                      fun_info.speed = cur_speed;
  76   4                      flag_get_speed = 1;
  77   4                  }
  78   3              }
  79   2              else
  80   2              {
  81   3                  // å¦‚æœé€Ÿåº¦æœªå‘ç”Ÿå˜åŒ–
  82   3                  speed_increases_cnt = 0;
  83   3                  speed_decreases_cnt = 0;
  84   3              }
  85   2          }
  86   1      }
  87          
  88          // P0ä¸­æ–­æœåŠ¡å‡½æ•°
  89          void P0_IRQHandler(void) interrupt P0_IRQn
  90          {
  91   1          // Px_PNDå¯„å­˜å™¨å†™ä»»ä½•å€¼éƒ½ä¼šæ¸…æ ‡å¿—ä½
  92   1          u8 p0_pnd = P0_PND;
  93   1      
  94   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
  95   1          __IRQnIPnPush(P0_IRQn);
  96   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
  97   1          if (p0_pnd & GPIO_P02_IRQ_PNG(0x1))
  98   1          {
  99   2              detect_speed_pulse_cnt++;
 100   2          }
 101   1          P0_PND = p0_pnd; // æ¸…P0ä¸­æ–­æ ‡å¿—ä½
 102   1          // -------------------------------------------------
 103   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 104   1          __IRQnIPnPop(P0_IRQn);
 105   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    378    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14       4
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/20/2024 15:06:13 PAGE 3   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
